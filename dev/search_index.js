var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Summary","page":"Usage","title":"Summary","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The way that trashing is performed differs wildly between platforms:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"On Linux, we trashing works by moving files and creating/reading paired ini-style .trashinfo files (this is the Freedesktop Trashspec).\nOn MacOS, trashing is done using the Objective-C API, specifically trashItemAtURL:resultingItemURL:error: and manually parsing the .DS_Store file.\nOn Windows, the Win32 IFileOperation::DeleteItem API is used for trashing, and the remaining functionality is implemented by manually inspecting the recycling bin.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"These large differences make a coherent cross-platform API a bit difficult, but by focusing on just supporting basic functionality (trashing and untrashing, listing and emptying trash contents) we have a solid cross-platform trash library.","category":"page"},{"location":"usage/#Example-usage","page":"Usage","title":"Example usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> using Trash\n\njulia> write(\"demofile\", \"some content\")\n12\n\njulia> trash(\"demofile\")\nTrashFile(\"/tmp/demofile\" @ 2025-04-27)\n\njulia> write(\"demofile\", \"more content\")\n12\n\njulia> trash(\"demofile\")\nTrashFile(\"/tmp/demofile\" @ 2025-04-27)\n\njulia> Trash.search(\"demofile\")\n2-element Vector{TrashFile}:\n TrashFile(\"/tmp/demofile\" @ 2025-04-27)\n TrashFile(\"/tmp/demofile\" @ 2025-04-27)\n\njulia> untrash(\"demofile\", pick = :oldest)\n\"demofile\"\n\njulia> read(\"demofile\", String)\n\"some content\"\n\njulia> untrash(\"demofile\", force = true)\n\"demofile\"\n\njulia> read(\"demofile\", String)\n\"more content\"","category":"page"},{"location":"usage/#Functions","page":"Usage","title":"Functions","text":"","category":"section"},{"location":"usage/#Trash.trash","page":"Usage","title":"Trash.trash","text":"trash(path::AbstractString; force::Bool=false)\n\nPut the file, link, or empty directory in the system trash. If force=true is passed, a non-existing path is not treated as an error.\n\nSee also: Trash.list, untrash.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Trash.untrash","page":"Usage","title":"Trash.untrash","text":"untrash(entry::TrashFile, dest::AbstractString = original path;\n        force::Bool = false, rm::Bool = false)\n\nRestore a file, link, or directory represented by entry from the system trash.\n\nThe entry will be restored to the path dest, which defaults to the original location of the entry.\n\nIf force is true, any existing file at the destination will be trashed, and if rm is true, the file will be removed with Base.rm.\n\nSee also: trash, Trash.list.\n\n\n\n\n\nuntrash(path::AbstractString, dest::AbstractString = path; pick::Symbol = :only,\n        force::Bool = false, rm::Bool = false)\n\nRestore the original contents of path, optionally specifying a different destination.\n\nThe path is the original path of the file or directory to be restored, and has no connection to how the resource is stored in the trash.\n\nShould multiple entries of path exist in the trash, an entry will be chosen based on the pick option. The default is :only, which will throw an ArgumentError if multiple entries are found. The other options are :newest and :oldest, which will select the most recent or oldest entry, respectively.\n\nThe force and rm options are passed through to the untrash(::TrashFile) function.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Trash.trashdir","page":"Usage","title":"Trash.trashdir","text":"trashdir() -> String\n\nReturn the general trash directory for the current user.\n\n\n\n\n\ntrashdir(path::AbstractString) -> String\n\nReturn the trash directory used for path.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Trash.trashes","page":"Usage","title":"Trash.trashes","text":"trashes() -> Vector{String}\n\nReturn a list of all trash directories on the system.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Trash.list","page":"Usage","title":"Trash.list","text":"list() -> Vector{TrashFile}\n\nList all entries current in an accessible trash directory.\n\nThis searches the system for trash directories on local, mounted, writable filesystems (including removable drives) and combines results into a single list.\n\nFilesystems that are network-based (e.g. NFS, SMB, or SSHFS) are skipped.\n\nSee also: trash, untrash, orphans.\n\n\n\n\n\nlist(trashdir::AbstractString) -> Vector{TrashFile}\n\nList all entries currently in the trash directory trashdir.\n\nSee also: trashdir, search.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Trash.search","page":"Usage","title":"Trash.search","text":"search(path::AbstractString) -> Vector{TrashFile}\n\nSearch for path entries in the trash.\n\nThis is a minor convenience function on top of Trash.list, which see.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Trash.orphans","page":"Usage","title":"Trash.orphans","text":"orphans() -> Vector{TrashFile}\n\nList all entries in the trash that are missing data or metadata.\n\nOrphaned entries can occur when an operation has been interrupted, encountered an unexpected state and failed halfway, or when either a non-compliant tool or user has been fiddling with the trash directory.\n\nDangling data produces TrashFile entries with an empty path, while dangling metadata produces full TrashFile entries that cannot be restored.\n\nThis searches the system for trash directories on local, mounted, writable filesystems (including removable drives) and combines results into a single list.\n\nFilesystems that are network-based (e.g. NFS, SMB, or SSHFS) are skipped.\n\nSee also: Trash.list, Trash.purge.\n\n\n\n\n\norphans(trashdir::AbstractString) -> Vector{TrashFile}\n\nList all entries in the trash directory trashdir that are missing data or metadata.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Trash.purge","page":"Usage","title":"Trash.purge","text":"purge(entry::TrashFile)\n\nPermanently delete the entry entry from the trash.\n\nTo the extent possible, this will remove the data and metadata associated with the entry, and will not be recoverable.\n\nSee also: Trash.list, Trash.orphans, Trash.empty.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Trash.empty","page":"Usage","title":"Trash.empty","text":"empty()\n\nEmpty the user trash.\n\nSee also: trash, Trash.list.\n\n\n\n\n\nempty(trashdir::AbstractString)\n\nEmpty the trash directory trashdir.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Types","page":"Usage","title":"Types","text":"","category":"section"},{"location":"usage/#Trash.TrashFile","page":"Usage","title":"Trash.TrashFile","text":"TrashFile\n\nA representation of a file that has been trashed.\n\nThis representation contains:\n\nthe path to the trash file,\nthe path to the original file, and\nthe time it was trashed\n\n\n\n\n\n","category":"type"},{"location":"usage/#Platform-complications","page":"Usage","title":"Platform complications","text":"","category":"section"},{"location":"usage/#Linux-(XDG-Trash)","page":"Usage","title":"Linux (XDG Trash)","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Everything works great 🙂.","category":"page"},{"location":"usage/#MacOS","page":"Usage","title":"MacOS","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The \"put back\" functionality is broken, as the .DS_Store file is not properly modified with the provided system APIs. See https://openradar.appspot.com/23153124 for more information. This also means that we inevitably create orphaned metadata.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We rely on parsing the (undocumented) .DS_Store file to read trash information.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To correct for the \"put back\" bug, and also update metadata when restoring/purging trash entries, the feasibility of editing the .DS_Store file has been considered. However, other people's investigations indicate that Finder holds an in-memory copy of the file which is prone to being used to overwrite any changes made. This makes the idea of editing the .DS_Store file seem rather poor, both due to the unpredictability of the final state and also the risk of corruption, depending on how our modifications to the file interact with how the Finder system handles it.","category":"page"},{"location":"usage/#Windows","page":"Usage","title":"Windows","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Everything works, but trashing a file with knowledge of where it ended up and the associated deletion time is rather involved. It's about a thousand times slower to delete a file on Windows than Linux or MacOS, but unless you're wanting to trash thousands and thousands of files, this shouldn't be a concern.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We rely on an undocumented convention for the recycle bin path, as SHGetKnownFolderPath pretends that the recycle bin does not correspond to a physical folder (even though it does). We also rely on the (undocumented) existence of $R... and parsed data from $I... files in the recycle bin to retrieve information on the contents of the recycle bin.","category":"page"},{"location":"#Trash","page":"Introduction","title":"Trash","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Sometimes you want to get rid of a file, but make it possible for it to be restored later (by your program or the user).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The way this should be done varies by operating system. This library helps you handle this simply and in a (largely, see Platform Complications) cross-platform way with trash. It's no surprise that the utility of this function has been realised across multiple language ecosystems, with a healthy collection of cross-platform trash libraries floating around. Most of these only provide the ability to send a file to the trash, but Trash.jl goes further, giving you the ability to restore items with untrash, inspect the contents of the trash with list, and delete the trash with empty.","category":"page"},{"location":"#Comparison-with-existing-libraries","page":"Introduction","title":"Comparison with existing libraries","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Library Language Library/CLI Platforms Trash Untrash List Orphans Purge Empty\nTrash.jl Julia 📚 🐧 🍏 🪟 ✅️️ ✅️ ✅️ ✅ ✅ ✅️\ntrash-rs Rust 📚 + 🐚 🐧 🍏 🪟 ✅️ ❌ ❌ ❌ ❌ ❌\nsend2trash Python 📚 🐧 🍏 🪟 ✅️ ❌ ❌ ❌ ❌ ❌\ntrash JavaScript 📚 + 🐚 🐧 🍏 🪟 ✅️ ❌ ❌ ❌ ❌ ❌\ngomi Go 🐚 🐧 🍏 🪟 ✅ 🐧 🐧 🐧 ❌ ❌\nTrashman C# 🐚 🐧 〰️️ 🪟 ✅ ✅ ✅ ❌ ✅ ✅\ntrash-cli Python 🐚 🐧 〰️️ 〰️️ ✅️ ✅️ ✅️ ❌ ✅ ✅️\ntrash-d D 🐚 🐧 〰️️ 〰️️ ✅️ ✅️ ✅️ ✅ ✅ ✅️\nGIO C 📚 🐧 〰️️ 〰️️ ✅️ ✅ ✅ ❌ ❌ ✅\nKIO C++ 📚 🐧 〰️️ 〰️️ ✅️ ✅ ❌ ❌ ❌ ✅️\nDS_Store parser Python 📚 〰️️ 🍏 〰️️ ❌ ❌ ✅ ❌ ❌ ❌\nFoundation ObjC/Swift 📚 〰️️ 🍏 〰️️ ✅️ ❌ ❌ ❌ ❌ ❌\nrifiuti2 C 🐚 〰️️ 〰️️ 🪟 ❌ ❌ ✅ ❌ ❌ ❌\nwinshell Python 📚 〰️️ 〰️️ 🪟 ✅️ ✅️ ✅️ ❌ ❌ ✅️\nwin32 C 📚 〰️️ 〰️️ 🪟 ✅️ ❌ ❌ ❌ ❌ ✅️","category":"page"}]
}
